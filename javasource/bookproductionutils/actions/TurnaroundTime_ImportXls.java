// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package bookproductionutils.actions;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.Supplier;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.ss.usermodel.DataFormatter;
import org.apache.poi.ss.usermodel.DateUtil;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.UserAction;
import com.mendix.systemwideinterfaces.core.UserException;
import com.mendix.systemwideinterfaces.core.UserException.ExceptionCategory;
import bookproductionutils.proxies.TurnaroundTimeItem;
import bookproductionutils.proxies.TurnaroundTimeX;

public class TurnaroundTime_ImportXls extends UserAction<java.util.List<IMendixObject>>
{
	/** @deprecated use excelFile.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __excelFile;
	private final system.proxies.FileDocument excelFile;

	public TurnaroundTime_ImportXls(
		IContext context,
		IMendixObject _excelFile
	)
	{
		super(context);
		this.__excelFile = _excelFile;
		this.excelFile = _excelFile == null ? null : system.proxies.FileDocument.initialize(getContext(), _excelFile);
	}

	@java.lang.Override
	public java.util.List<IMendixObject> executeAction() throws Exception
	{
		// BEGIN USER CODE
        context = getContext();
        try (
            final InputStream in =
                Core.getFileDocumentContent(context, excelFile.getMendixObject());
            final Workbook workbook = openWorkbook(in, excelFile.getName())) {
            if (workbook.getNumberOfSheets() != 1) {
                throw new UserException(
                    ExceptionCategory.Custom,
                    "Expected exactly one sheet in Excel Workbook: " + excelFile.getName());
            }
            final Sheet sheet = workbook.getSheetAt(0);
            final Iterator<Row> it = sheet.rowIterator();
            row = it.next();
            firstHeader = parseHeaderRow(row);

            final List<Integer> prodCatIndexes = firstHeader.get(COL_PRODUCTION_CATEGORY);

            if (prodCatIndexes == null) {
                throw new UserException(
                    ExceptionCategory.Custom,
                    "Expected the first row to contain: " + COL_PRODUCTION_CATEGORY);
            }
            row = it.next();
            secondHeader = parseHeaderRow(row);
            if (!(secondHeader.containsKey(COL_TASK) && secondHeader
                .containsKey(COL_COPYEDITINGCATEGORY))) {
                throw new UserException(
                    ExceptionCategory.Custom,
                    "Expected the second row to contain: " + COL_TASK + " and "
                        + COL_COPYEDITINGCATEGORY);
            }

            prodCatsByIndex = LinkedHashMap.newLinkedHashMap(prodCatIndexes.size());
            for (final Integer prodCatColIndex : prodCatIndexes) {
                final Cell cell = row.getCell(prodCatColIndex);
                final String code = str1(cell);

                if (prodCatsByIndex.containsValue(code)) {
                    throw new UserException(
                        ExceptionCategory.Custom,
                        "Cell " + cell.getAddress() + " contains the same " + "prodcat"
                            + " code as one of the previous cells: " + code);
                }

                prodCatsByIndex.put(prodCatColIndex, code);
            }

            final List<IMendixObject> toCommit = new ArrayList<>();
            while (it.hasNext()) {
                row = it.next();
                final String task2 = getTask2();
                final String copyEds2 = getCopyEds2();
                if (task2 != null && copyEds2 != null) {
                    final TurnaroundTimeX turnaroundTime = new TurnaroundTimeX(context);
                    turnaroundTime.setTaskCode(task2);
                    turnaroundTime.setPrettyCopyEds(copyEds2);
                    createItems(turnaroundTime);
                    toCommit.add(turnaroundTime.getMendixObject());
                    mCell = null;
                }
            }
            return toCommit;
        }
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "TurnaroundTime_ImportXls";
	}

	// BEGIN EXTRA CODE

    private static final String COL_PRODUCTION_CATEGORY = "Production Category";

    private static final Object COL_TASK = "Task";

    private static final Object COL_COPYEDITINGCATEGORY = "CopyEditingCategory";

    private static final DataFormatter DATA_FORMATTER = new DataFormatter();

    private Map<String, List<Integer>> firstHeader;

    private Map<Integer, String> prodCatsByIndex;

    private Map<String, List<Integer>> secondHeader;

    private Cell mCell;

    private IContext context;

    private Row row;

    private String getTask2() throws Exception {
        final Cell cellTask = getCell(COL_TASK);
        final String code = str1(cellTask);
        mCell = null;
        return code.isEmpty() ? null : code;
    }

    private String getCopyEds2() throws Exception {
        final Cell cellCopyEds = getCell(COL_COPYEDITINGCATEGORY);
        final String sCopyEds = str1(cellCopyEds);
        mCell = null;
        return sCopyEds.isEmpty() ? null : sCopyEds;
    }

    private void createItems(final TurnaroundTimeX turnaroundTime) throws Exception {
        for (final var pair : prodCatsByIndex.entrySet()) {
            final Integer prodCatColIndex = pair.getKey();
            final Cell cell = row.getCell(prodCatColIndex);
            final String sNumber = str1(cell);
            Integer number;
            try {
                number = Integer.parseInt(sNumber);
            } catch (final NumberFormatException e) {
                throw new UserException(
                    ExceptionCategory.Custom,
                    "Cell " + cell.getAddress() + " contains invalid number of days: " + sNumber);
            }
            final String prodCat = pair.getValue();
            final TurnaroundTimeItem turnaroundTimeItem = new TurnaroundTimeItem(context);
            turnaroundTimeItem.setNumberOfDays(number);
            turnaroundTimeItem.setAttribute(prodCat);
            turnaroundTimeItem.setTurnaroundTimeItem_TurnaroundTimeX(turnaroundTime);
        }
    }

    private static <T> T requireNonNull(final T obj, final Supplier<String> messageSupplier) {
        if (obj == null) {
            throw new UserException(
                UserException.ExceptionCategory.Custom,
                messageSupplier == null ? null : messageSupplier.get());
        }
        return obj;
    }

    private Cell getCell(final Object memberName) {
        mCell =
            row
                .getCell(
                    requireNonNull(
                        secondHeader.get(memberName.toString()),
                        () -> "Column not found: " + memberName).get(0));
        return mCell;
    }

    private Map<String, List<Integer>> parseHeaderRow(final Row headerRow) throws Exception {
        final Map<String, List<Integer>> indexesByTitle = new HashMap<>();
        for (final Cell headerCell : headerRow) {
            final String title = str1(headerCell);

            if (!title.isEmpty()) {
                final List<Integer> indexes =
                    indexesByTitle.computeIfAbsent(title, unused -> new ArrayList<>());
                indexes.add(headerCell.getColumnIndex());
            }
        }
        return indexesByTitle;
    }

    private Workbook openWorkbook(final InputStream in, final String fileName) {
        try {
            return FilenameUtils.isExtension(fileName, "xls")
                ? new HSSFWorkbook(in)
                : new XSSFWorkbook(in);
        } catch (final IOException e) {
            throw new UserException(
                ExceptionCategory.Custom,
                "Failed to parse Excel Workbook: " + fileName + ": " + e.getMessage());
        }
    }

    private String str1(final Cell cell) throws Exception {
        Cell cell2 = cell;
        final Sheet sheet = cell.getSheet();
        final List<CellRangeAddress> mergedRegions = sheet.getMergedRegions();
        for (final CellRangeAddress mergeRange : mergedRegions) {
            if (mergeRange.isInRange(cell)) {
                cell2 = sheet.getRow(mergeRange.getFirstRow()).getCell(mergeRange.getFirstColumn());
                break;
            }
        }
        return str0(cell2);
    }

    private String str0(final Cell cell) throws Exception {
        return s(cell).trim();
    }

    private String s(final Cell cell) throws Exception {
        return StringUtils.defaultString(getCellValue(cell));
    }

    private static String getCellValue(final Cell cell) throws Exception {
        if (cell == null) {
            return "";
        }
        final CellType cellType = cell.getCellType();

        return getCellValue0(cell, cellType);
    }

    private static String getCellValue0(final Cell cell, final CellType cellType) throws Exception {
        switch (cellType) {
            case STRING:
                return cell.getRichStringCellValue().getString();
            case NUMERIC:
                return getNumericCellValue(cell);
            case BOOLEAN:
                return Boolean.toString(cell.getBooleanCellValue());
            case BLANK:
                return null;
            case FORMULA:
                return getCachedFormulaResult(cell);
            default: {
                final String cellLocation = cell.getRowIndex() + "," + cell.getColumnIndex();
                throw new Exception("Unknown type " + cellType.name() + " at " + cellLocation);
            }
        }
    }

    private static String getCachedFormulaResult(final Cell cell) throws Exception {
        final CellType cachedCellType = cell.getCachedFormulaResultType();
        return getCellValue0(cell, cachedCellType);
    }

    private static String getNumericCellValue(final Cell cell) {
        final String value;
        if (DateUtil.isCellDateFormatted(cell)) {
            value = DATA_FORMATTER.formatCellValue(cell);
        } else {
            value = DATA_FORMATTER.formatCellValue(cell);
        }

        return value;
    }

	// END EXTRA CODE
}
