// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package bookproductionutils.actions;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.ss.usermodel.DataFormatter;
import org.apache.poi.ss.usermodel.DateUtil;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import com.mendix.core.Core;
import com.mendix.core.CoreException;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.UserAction;
import com.mendix.systemwideinterfaces.core.UserException;
import com.mendix.systemwideinterfaces.core.UserException.ExceptionCategory;
import _sysutils.impl.LambdaUtil.BiFunctionWithExceptions;
import avatarclient.proxies.LVAItem;
import avatarclient.proxies.va_copyediting_category;
import avatarclient.proxies.va_production_category;
import avatarclient.proxies.va_production_schedule_task;
import bookproductionutils.proxies.TurnaroundTimeItem;
import bookproductionutils.proxies.TurnaroundTimeX;

public class TurnaroundTime_ImportXls extends UserAction<java.util.List<IMendixObject>>
{
	/** @deprecated use excelFile.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __excelFile;
	private final system.proxies.FileDocument excelFile;

	public TurnaroundTime_ImportXls(
		IContext context,
		IMendixObject _excelFile
	)
	{
		super(context);
		this.__excelFile = _excelFile;
		this.excelFile = _excelFile == null ? null : system.proxies.FileDocument.initialize(getContext(), _excelFile);
	}

	@java.lang.Override
	public java.util.List<IMendixObject> executeAction() throws Exception
	{
		// BEGIN USER CODE
        context = getContext();
        try (
            final InputStream in =
                Core.getFileDocumentContent(context, excelFile.getMendixObject());
            final Workbook workbook = openWorkbook(in, excelFile.getName())) {
            if (workbook.getNumberOfSheets() != 1) {
                throw new UserException(
                    ExceptionCategory.Custom,
                    "Expected exactly one sheet in Excel Workbook: " + excelFile.getName());
            }
            final Sheet sheet = workbook.getSheetAt(0);
            final Iterator<Row> it = sheet.rowIterator();
            row = it.next();
            firstHeader = parseHeaderRow(row);

            final List<Integer> prodCatIndexes = firstHeader.get(COL_PRODUCTION_CATEGORY);

            if (prodCatIndexes == null) {
                throw new UserException(
                    ExceptionCategory.Custom,
                    "Expected the first row to contain: " + COL_PRODUCTION_CATEGORY);
            }
            row = it.next();
            secondHeader = parseHeaderRow(row);
            if (!(secondHeader.containsKey(COL_TASK) && secondHeader
                .containsKey(COL_COPYEDITINGCATEGORY))) {
                throw new UserException(
                    ExceptionCategory.Custom,
                    "Expected the second row to contain: " + COL_TASK + " and "
                        + COL_COPYEDITINGCATEGORY);
            }

            final Map<String, va_production_schedule_task> tasksByCode =
                loadVA(va_production_schedule_task::load);

            final Map<String, va_copyediting_category> copyEdsByCode =
                loadVA(va_copyediting_category::load);

            final Map<String, va_production_category> prodCatsByCode =
                loadVA(va_production_category::load);

            prodCatsByIndex = LinkedHashMap.newLinkedHashMap(prodCatIndexes.size());
            for (final Integer prodCatColIndex : prodCatIndexes) {
                final Cell cell = row.getCell(prodCatColIndex);
                final va_production_category prodCat =
                    getVA(cell, prodCatsByCode, va_production_category.entityName, false);
                prodCatsByIndex.put(prodCatColIndex, prodCat);
            }

            final List<IMendixObject> toCommit = new ArrayList<>();
            while (it.hasNext()) {
                row = it.next();
                final va_production_schedule_task task = getTask(tasksByCode);
                final List<va_copyediting_category> copyEds = getCopyEds(copyEdsByCode);
                if (task != null && copyEds != null) {
                    final TurnaroundTimeX turnaroundTime = new TurnaroundTimeX(context);
                    turnaroundTime.setTurnaroundTimeX_va_production_schedule_task(task);
                    turnaroundTime.setTurnaroundTimeX_va_copyediting_category(copyEds);
                    createItems(turnaroundTime);
                    toCommit.add(turnaroundTime.getMendixObject());
                    mCell = null;
                }
            }
            return toCommit;
        }
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "TurnaroundTime_ImportXls";
	}

	// BEGIN EXTRA CODE

    private static final String COL_PRODUCTION_CATEGORY = "Production Category";

    private static final Object COL_TASK = "Task";

    private static final Object COL_COPYEDITINGCATEGORY = "CopyEditingCategory";

    private static final DataFormatter DATA_FORMATTER = new DataFormatter();

    private Map<String, List<Integer>> firstHeader;

    private Map<Integer, va_production_category> prodCatsByIndex;

    private Map<String, List<Integer>> secondHeader;

    private Cell mCell;

    private IContext context;

    private Row row;

    private <T extends LVAItem> Map<String, T> loadVA(
            final BiFunctionWithExceptions<IContext, String, List<T>, CoreException> loadFunc1)
                                                                                                throws CoreException {
        final List<T> all_va_production_schedule_task = loadFunc1.apply(context, "");

        final Map<String, T> tasksByCode =
            all_va_production_schedule_task
                .stream()
                .collect(Collectors.toMap(x -> x.getCode(), Function.identity()));
        return tasksByCode;
    }

    private <T extends LVAItem> T getVA(
            final Cell cell,
            final Map<String, T> vaByCodeMap,
            final String entityname,
            final boolean ignoreEmpty) throws Exception {
        final String code = str1(cell);
        if (code.isEmpty() && ignoreEmpty) {
            return null;
        }
        final T va = vaByCodeMap.get(code);
        if (va == null) {
            throw new UserException(
                ExceptionCategory.Custom,
                "Cell " + cell.getAddress() + " contains unknown " + entityname + " code: " + code);
        }
        if (prodCatsByIndex.containsValue(va)) {
            throw new UserException(
                ExceptionCategory.Custom,
                "Cell " + cell.getAddress() + " contains the same " + entityname
                    + " code as one of the previous cells: " + code);
        }
        return va;
    }

    private va_production_schedule_task getTask(
            final Map<String, va_production_schedule_task> tasksByCode) throws Exception {
        final Cell cellTask = getCell(COL_TASK);
        final va_production_schedule_task task =
            getVA(cellTask, tasksByCode, va_production_schedule_task.entityName, true);
        mCell = null;
        return task;
    }

    private List<va_copyediting_category> getCopyEds(
            final Map<String, va_copyediting_category> copyEdsByCode) throws Exception {
        final Cell cellCopyEds = getCell(COL_COPYEDITINGCATEGORY);
        final String sCopyEds = str1(cellCopyEds);
        List<va_copyediting_category> copyEds = null;
        if (!sCopyEds.isEmpty()) {
            copyEds = new ArrayList<>();
            if (!"*".equals(sCopyEds)) {
                for (String sCopyEditingCategory : sCopyEds.split(",")) {
                    sCopyEditingCategory = sCopyEditingCategory.trim();
                    if (!sCopyEditingCategory.startsWith("CE")) {
                        throw new UserException(
                            ExceptionCategory.Custom,
                            "Cell " + cellCopyEds.getAddress()
                                + " contains a comma-separated list element not starting with 'CE': "
                                + sCopyEditingCategory);
                    }
                    final String code = sCopyEditingCategory.substring("CE".length());
                    final va_copyediting_category copyEd =
                        copyEdsByCode.get(code);
                    if (copyEd == null) {
                        throw new UserException(
                            ExceptionCategory.Custom,
                            "Cell " + cellCopyEds.getAddress() + " contains unknown "
                                + va_copyediting_category.entityName + " code: " + code);
                    }
                    copyEds.add(copyEd);
                }
            }
        }
        mCell = null;
        return copyEds;
    }

    private void createItems(final TurnaroundTimeX turnaroundTime) throws Exception {
        for (final var pair : prodCatsByIndex.entrySet()) {
            final Integer prodCatColIndex = pair.getKey();
            final Cell cell = row.getCell(prodCatColIndex);
            final String sNumber = str1(cell);
            Integer number;
            try {
                number = Integer.parseInt(sNumber);
            } catch (final NumberFormatException e) {
                throw new UserException(
                    ExceptionCategory.Custom,
                    "Cell " + cell.getAddress() + " contains invalid number of days: " + sNumber);
            }
            final va_production_category prodCat = pair.getValue();
            final TurnaroundTimeItem turnaroundTimeItem = new TurnaroundTimeItem(context);
            turnaroundTimeItem.setNumberOfDays(number);
            turnaroundTimeItem.setTurnaroundTimeItem_va_production_category(prodCat);
            turnaroundTimeItem.setTurnaroundTimeItem_TurnaroundTimeX(turnaroundTime);
        }
    }

    private static <T> T requireNonNull(final T obj, final Supplier<String> messageSupplier) {
        if (obj == null) {
            throw new UserException(
                UserException.ExceptionCategory.Custom,
                messageSupplier == null ? null : messageSupplier.get());
        }
        return obj;
    }

    private Cell getCell(final Object memberName) {
        mCell =
            row
                .getCell(
                    requireNonNull(
                        secondHeader.get(memberName.toString()),
                        () -> "Column not found: " + memberName).get(0));
        return mCell;
    }

    private Map<String, List<Integer>> parseHeaderRow(final Row headerRow) throws Exception {
        final Map<String, List<Integer>> indexesByTitle = new HashMap<>();
        for (final Cell headerCell : headerRow) {
            final String title = str1(headerCell);

            if (!title.isEmpty()) {
                final List<Integer> indexes =
                    indexesByTitle.computeIfAbsent(title, unused -> new ArrayList<>());
                indexes.add(headerCell.getColumnIndex());
            }
        }
        return indexesByTitle;
    }

    private Workbook openWorkbook(final InputStream in, final String fileName) {
        try {
            return FilenameUtils.isExtension(fileName, "xls")
                ? new HSSFWorkbook(in)
                : new XSSFWorkbook(in);
        } catch (final IOException e) {
            throw new UserException(
                ExceptionCategory.Custom,
                "Failed to parse Excel Workbook: " + fileName + ": " + e.getMessage());
        }
    }

    private String str1(final Cell cell) throws Exception {
        Cell cell2 = cell;
        final Sheet sheet = cell.getSheet();
        final List<CellRangeAddress> mergedRegions = sheet.getMergedRegions();
        for (final CellRangeAddress mergeRange : mergedRegions) {
            if (mergeRange.isInRange(cell)) {
                cell2 = sheet.getRow(mergeRange.getFirstRow()).getCell(mergeRange.getFirstColumn());
                break;
            }
        }
        return str0(cell2);
    }

    private String str0(final Cell cell) throws Exception {
        return s(cell).trim();
    }

    private String s(final Cell cell) throws Exception {
        return StringUtils.defaultString(getCellValue(cell));
    }

    private static String getCellValue(final Cell cell) throws Exception {
        if (cell == null) {
            return "";
        }
        final CellType cellType = cell.getCellType();

        return getCellValue0(cell, cellType);
    }

    private static String getCellValue0(final Cell cell, final CellType cellType) throws Exception {
        switch (cellType) {
            case STRING:
                return cell.getRichStringCellValue().getString();
            case NUMERIC:
                return getNumericCellValue(cell);
            case BOOLEAN:
                return Boolean.toString(cell.getBooleanCellValue());
            case BLANK:
                return null;
            case FORMULA:
                return getCachedFormulaResult(cell);
            default: {
                final String cellLocation = cell.getRowIndex() + "," + cell.getColumnIndex();
                throw new Exception("Unknown type " + cellType.name() + " at " + cellLocation);
            }
        }
    }

    private static String getCachedFormulaResult(final Cell cell) throws Exception {
        final CellType cachedCellType = cell.getCachedFormulaResultType();
        return getCellValue0(cell, cachedCellType);
    }

    private static String getNumericCellValue(final Cell cell) {
        final String value;
        if (DateUtil.isCellDateFormatted(cell)) {
            value = DATA_FORMATTER.formatCellValue(cell);
        } else {
            value = DATA_FORMATTER.formatCellValue(cell);
        }

        return value;
    }

	// END EXTRA CODE
}
