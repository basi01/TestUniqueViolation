// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package avatarclient.actions;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.ss.usermodel.DataFormatter;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import com.mendix.core.Core;
import com.mendix.logging.ILogNode;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.UserAction;
import com.mendix.thirdparty.org.json.JSONObject;
import avatarclient.proxies.LVAItem;
import avatarclient.proxies.constants.Constants;

public class VATypeXlsImport extends UserAction<java.lang.Void>
{
	/** @deprecated use excelFile.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __excelFile;
	private final system.proxies.FileDocument excelFile;

	public VATypeXlsImport(
		IContext context,
		IMendixObject _excelFile
	)
	{
		super(context);
		this.__excelFile = _excelFile;
		this.excelFile = _excelFile == null ? null : system.proxies.FileDocument.initialize(getContext(), _excelFile);
	}

	@java.lang.Override
	public java.lang.Void executeAction() throws Exception
	{
		// BEGIN USER CODE
        final IContext context = getContext();
        try (
            InputStream in = Core.getFileDocumentContent(context, excelFile.getMendixObject());
            Workbook workbook = openWorkbook(in, excelFile.getName())) {
            Sheet dataDepSheet = null;
            for (final Sheet sheet : workbook) {
                if (Objects.equals(sheet.getSheetName(), Constants.getDataDepSheetName())) {
                    dataDepSheet = sheet;
                    continue;
                }
                final Iterator<Row> rowit = sheet.rowIterator();

                if (rowit.hasNext()) {
                    final Row headerRow = rowit.next();

                    parseHeaderRow(headerRow);
                    if (indexesByTitle == null) {
                        continue;
                    }

                    final String vaType = "AvatarClient." + sheet.getSheetName();
                    final Map<String, IMendixObject> vaMap = loadVaMap(vaType);

                    while (rowit.hasNext()) {
                        row = rowit.next();
                        addVaItem(vaMap, vaType);
                    }
                    Core.commit(context, new ArrayList<>(vaMap.values()));
                }
            }
            if (false && dataDepSheet != null) {
                final Sheet sheet = dataDepSheet;

                final Iterator<Row> rowit = sheet.rowIterator();

                if (rowit.hasNext()) {
                    final Row headerRow = rowit.next();

                    parseHeaderRow2(headerRow);
                    if (indexesByTitle != null) {

                        while (rowit.hasNext()) {
                            row = rowit.next();
                            addVaItem2();
                        }

                    }
                }
            }
        }
        return null;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "VATypeXlsImport";
	}

	// BEGIN EXTRA CODE

    private static final ILogNode LOG = Core.getLogger("XLSreport");

    private Map<String, Integer> indexesByTitle;

    private Map<String, Integer> extraIndexesByTitle;

    private Row row;

    private void addVaItem(final Map<String, IMendixObject> vaMap, final String vaType)
                                                                                        throws Exception {

        emptyRow = true;
        final String code = s(c("Code"));
        final String term = s(c("Term"));
        final int sortKey = i(c("SortKey"));
        final boolean obsolete = b(c("Obsolete"));

        // TODO: extra values aren't imported
        Map<String, String> extraValues = Collections.emptyMap();
        if (!extraIndexesByTitle.isEmpty()) {
            extraValues = new HashMap<>();
            for (final Entry<String, Integer> pair : extraIndexesByTitle
                .entrySet()) {
                addExtraValue(extraValues, pair.getKey(), pair.getValue());
            }
        }
        if (!emptyRow) {
            IMendixObject mxVa = vaMap.get(code);
            if (mxVa == null) {
                mxVa = Core.instantiate(getContext(), vaType);
                vaMap.put(code, mxVa);
            }
            final LVAItem pxVa = LVAItem.initialize(getContext(), mxVa);
            pxVa.setCode(code);
            pxVa.setTerm(term);
            pxVa.setSortKey(sortKey);
            pxVa.setObsolete(obsolete);
        }
    }

    private boolean emptyRow;

    private void addVaItem2() throws Exception {
        final JSONObject jvaitem = new JSONObject();
        emptyRow = true;
        jvaitem.put("broader_type", s(c("Broader VA")));
        jvaitem.put("broader_item", s(c("Broader Code")));
        jvaitem.put("narrower_type", s(c("VA")));
        jvaitem.put("narrower_item", s(c("Code")));

        if (!emptyRow) {
            // writeJvat(jvaitem);
        }
    }

    private void addExtraValue(
            final Map<String, String> extraValues,
            final String extraAttr,
            final Integer index) throws Exception {
        final Cell cell = row.getCell(index);
        extraValues.put(extraAttr, s(cell));
    }

    private Cell c(final String name) {
        return row.getCell(indexesByTitle.get(name));
    }

    private void parseHeaderRow(final Row headerRow) throws Exception {
        indexesByTitle = new HashMap<>();
        extraIndexesByTitle = new LinkedHashMap<>();
        @SuppressWarnings("unchecked")
        final Set<String> remainingMandatoryCols = (Set<String>) MANDATORY_COLS.clone();

        for (final Cell headerCell : headerRow) {
            final String title = s(headerCell);
            if (!title.isEmpty()) {
                final Map<String, Integer> target =
                    remainingMandatoryCols.remove(title) ? indexesByTitle : extraIndexesByTitle;
                target.put(title, headerCell.getColumnIndex());
            }
        }
        if (!remainingMandatoryCols.isEmpty()) {
            LOG
                .warn(
                    "sheet " + headerRow.getSheet().getSheetName() + ": mandatory columns missing: "
                        + remainingMandatoryCols);
            indexesByTitle = null;
            return;
        }
    }

    private static final HashSet<String> MANDATORY_COLS =
        new HashSet<>(Arrays.asList("Obsolete", "SortKey", "Term", "Code"));

    private void parseHeaderRow2(final Row headerRow) throws Exception {
        indexesByTitle = new HashMap<>();
        @SuppressWarnings("unchecked")
        final Set<String> remainingMandatoryCols = (Set<String>) MANDATORY_COLS2.clone();

        for (final Cell headerCell : headerRow) {
            final String title = s(headerCell);
            if (!title.isEmpty()) {
                if (remainingMandatoryCols.remove(title)) {
                    indexesByTitle.put(title, headerCell.getColumnIndex());
                }
            }
        }
        if (!remainingMandatoryCols.isEmpty()) {
            LOG
                .warn(
                    "sheet " + headerRow.getSheet().getSheetName() + ": mandatory columns missing: "
                        + remainingMandatoryCols);
            indexesByTitle = null;
            return;
        }
    }

    private static final HashSet<String> MANDATORY_COLS2 =
        new HashSet<>(Arrays.asList("VA", "Code", "Broader VA", "Broader Code"));

    private Workbook openWorkbook(final InputStream in, final String fileName) throws IOException {
        return FilenameUtils.isExtension(fileName, "xls")
            ? new HSSFWorkbook(in)
            : new XSSFWorkbook(in);
    }

    private String s(final Cell cell) throws Exception {
        final String res = StringUtils.defaultString(getCellValue(cell));
        emptyRow &= res.isEmpty();
        return res;
    }

    private int i(final Cell cell) throws Exception {
        final String s = s(cell);
        return s.isEmpty() ? 0 : Integer.parseInt(s);
    }

    private boolean b(final Cell cell) throws Exception {
        final String s = s(cell);
        return !(s.isEmpty() || s.equalsIgnoreCase("false") || s.equals("0"));
    }

    private static String getCellValue(final Cell cell) throws Exception {
        if (cell == null) {
            return "";
        }
        final CellType cellType = cell.getCellType();

        return getCellValue0(cell, cellType);
    }

    private static String getCellValue0(final Cell cell, final CellType cellType) throws Exception {
        switch (cellType) {
            case STRING:
                return cell.getRichStringCellValue().getString();
            case NUMERIC:
                return getNumericCellValue(cell);
            case BOOLEAN:
                return Boolean.toString(cell.getBooleanCellValue());
            case BLANK:
                return null;
            case FORMULA:
                return getCachedFormulaResult(cell);
            default: {
                final String cellLocation = cell.getRowIndex() + "," + cell.getColumnIndex();
                throw new Exception(
                    "Unknown type " + cellType.name() + " at " + cellLocation);
            }
        }
    }

    private static String getCachedFormulaResult(final Cell cell) throws Exception {
        final CellType cachedCellType = cell.getCachedFormulaResultType();
        return getCellValue0(cell, cachedCellType);
    }

    private static String getNumericCellValue(final Cell cell) {
        // formatRawCellContents prevents formatting as unevaluated formulas
        final CellStyle cellStyle = cell.getCellStyle();
        final String value =
            DATA_FORMATTER
                .formatRawCellContents(
                    cell.getNumericCellValue(),
                    cellStyle.getDataFormat(),
                    cellStyle.getDataFormatString());

        return value;
    }

    private static final DataFormatter DATA_FORMATTER = new DataFormatter();

    private Map<String, IMendixObject> loadVaMap(final String entityName) {
        // TODO: excel doesn't contain Iden, can't properly init new LVAType
        // LVAType lvaType = LVAType.load(getContext(), LVAType.MemberNames.Name.toString());
        final List<IMendixObject> vaList =
            Core.createXPathQuery("//" + entityName).execute(getContext());
        return vaList
            .stream()
            .collect(
                Collectors
                    .toMap(
                        x -> x.getValue(getContext(), LVAItem.MemberNames.Code.toString()),
                        Function.identity()));
    }


	// END EXTRA CODE
}
